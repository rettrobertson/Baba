using System;
using Baba.Particles.Decorators;
using Baba.Particles.Decorators.Emission;
using Baba.Particles.EmissionTypes;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;


namespace Baba.Particles
{
    public static class ParticlePresets
    {
        public static ParticleEmitter MakeWin()
        {
            Random random = new Random();
            Color randomColor = GenerateRandomColor(0, 1, .7f, 1, .7f, 1);
            Color startColor = new Color(randomColor.R / 3, randomColor.G / 3, randomColor.B / 3);
            ParticleEmitter emitter = new ParticleEmitter();
            emitter.emissionRate = 0f;
            emitter.SetTexture("Square");
            emitter.ScheduleBurst(0, 1200);
            emitter.AddDecorator(new ColorOverLifetime(Gradient.From2Color(startColor, randomColor, .5f, .99f)));
            emitter.SetEmissionShape(new PointEmitter(EmissionShape.EmitType.AREA));

            emitter.AddDecorator(new InitialRadialVelocity(0, 360, .07f, 1f));
            emitter.blendState = BlendState.NonPremultiplied;
            emitter.AddDecorator(new InitialSize(0.05f, 0.07f));
            emitter.SetTexture("Square");
            emitter.SetLifetime(1, 2);

            return emitter;
        }
        public static ParticleEmitter MakeWinChange()
        {
            ParticleEmitter emitter = new ParticleEmitter();
            emitter.emissionRate = 0f;
            emitter.SetTexture("Square");
            emitter.ScheduleBurst(0, 1000);
            emitter.AddDecorator(new ColorOverLifetime(Gradient.FadeInOut(Color.Yellow)));
            emitter.AddDecorator(new InitialRadialVelocity(0, 360, .02f, .04f));
            emitter.AddDecorator(new InitialSize(0.06f, 0.08f));
            emitter.blendState = BlendState.NonPremultiplied;
            emitter.SetLifetime(.7f);
            emitter.SetEmissionShape(new RectangleEmitter(new EmissionTypes.Rectangle(0, 0, 1, 1), EmissionShape.EmitType.EDGE));
            emitter.SetTexture("Square");

            return emitter;
        }
        public static ParticleEmitter MakeYouChange()
        {
            ParticleEmitter emitter = new ParticleEmitter();
            emitter.emissionRate = 0f;
            emitter.SetTexture("Square");
            emitter.ScheduleBurst(0, 1000);
            emitter.AddDecorator(new ColorOverLifetime(Gradient.FadeInOut(Color.White)));
            emitter.AddDecorator(new InitialRadialVelocity(0, 360, .02f, .04f));
            emitter.AddDecorator(new InitialSize(0.06f, 0.08f));
            emitter.blendState = BlendState.NonPremultiplied;
            emitter.SetLifetime(.7f);
            emitter.SetEmissionShape(new RectangleEmitter(new EmissionTypes.Rectangle(0, 0, 1, 1), EmissionShape.EmitType.EDGE));
            emitter.SetTexture("Square");

            return emitter;
        }
        public static ParticleEmitter MakeObjectDestroyed()
        {
            ParticleEmitter emitter = new ParticleEmitter();
            emitter.emissionRate = 0f;
            emitter.SetTexture("Square");
            emitter.ScheduleBurst(0, 200);
            emitter.AddDecorator(new ColorOverLifetime(Gradient.FadeInOut(Color.WhiteSmoke)));
            emitter.AddDecorator(new InitialRadialVelocity(0, 360, 1f, 2f));
            emitter.AddDecorator(new InitialSize(0.1f, 0.2f));
            emitter.SetLifetime(.1f, 1);
            emitter.blendState = BlendState.NonPremultiplied;
            emitter.SetEmissionShape(new CircleEmitter(new Circle(.1f, Pivot.CENTER), EmissionShape.EmitType.AREA));
            emitter.SetTexture("Square");
            return emitter;
        }

        //Generated by ChatGPT!
        public static Color GenerateRandomColor(float minHue, float maxHue, float minSaturation, float maxSaturation, float minValue, float maxValue)
        {
            // Create a new instance of the Random class to generate random values
            Random random = new Random();

            // Generate random values for hue, saturation, and value within the specified ranges
            float hue = MathHelper.Lerp(minHue, maxHue, (float)random.NextDouble());
            float saturation = MathHelper.Lerp(minSaturation, maxSaturation, (float)random.NextDouble());
            float value = MathHelper.Lerp(minValue, maxValue, (float)random.NextDouble());

            // Convert the HSV color to RGB
            int r, g, b;
            if (saturation == 0)
            {
                // If saturation is 0, the color is a shade of gray
                r = g = b = (int)Math.Round(value * 255f);
            }
            else
            {
                float h = (hue % 1f) * 6f; // Convert hue to 0-5 range
                int i = (int)Math.Floor(h); // Get integer part of hue
                float f = h - i; // Get fractional part of hue
                float p = value * (1f - saturation);
                float q = value * (1f - saturation * f);
                float t = value * (1f - saturation * (1f - f));

                switch (i)
                {
                    case 0:
                        r = (int)Math.Round(value * 255f);
                        g = (int)Math.Round(t * 255f);
                        b = (int)Math.Round(p * 255f);
                        break;
                    case 1:
                        r = (int)Math.Round(q * 255f);
                        g = (int)Math.Round(value * 255f);
                        b = (int)Math.Round(p * 255f);
                        break;
                    case 2:
                        r = (int)Math.Round(p * 255f);
                        g = (int)Math.Round(value * 255f);
                        b = (int)Math.Round(t * 255f);
                        break;
                    case 3:
                        r = (int)Math.Round(p * 255f);
                        g = (int)Math.Round(q * 255f);
                        b = (int)Math.Round(value * 255f);
                        break;
                    case 4:
                        r = (int)Math.Round(t * 255f);
                        g = (int)Math.Round(p * 255f);
                        b = (int)Math.Round(value * 255f);
                        break;
                    default: // case 5:
                        r = (int)Math.Round(value * 255f);
                        g = (int)Math.Round(p * 255f);
                        b = (int)Math.Round(q * 255f);
                        break;
                }
            }

            return new Color(r, g, b);
        }
    }
}
